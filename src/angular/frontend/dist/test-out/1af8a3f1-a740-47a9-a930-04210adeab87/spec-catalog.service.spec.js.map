{
  "version": 3,
  "sources": ["src/app/core/services/catalog.service.spec.ts", "src/app/core/services/catalog.service.ts"],
  "sourcesContent": ["import { TestBed } from '@angular/core/testing';\r\nimport { of, throwError } from 'rxjs';\r\n\r\nimport { ApiService } from './api.service';\r\nimport { CatalogItem, CatalogService } from './catalog.service';\r\n\r\ndescribe('CatalogService', () => {\r\n  let service: CatalogService;\r\n  let apiService: jasmine.SpyObj<ApiService>;\r\n\r\n  beforeEach(() => {\r\n    apiService = jasmine.createSpyObj<ApiService>('ApiService', ['get']);\r\n\r\n    TestBed.configureTestingModule({\r\n      providers: [\r\n        CatalogService,\r\n        { provide: ApiService, useValue: apiService }\r\n      ]\r\n    });\r\n\r\n    service = TestBed.inject(CatalogService);\r\n  });\r\n\r\n  it('combina produtos, pacotes e catálogo público sem duplicar itens', (done) => {\r\n    // O serviço agora consome apenas /public/catalog (endpoint unificado).\r\n    const payload = [\r\n      { id: 1, title: 'E-book', description: 'curta', format: 'EBOOK' },\r\n      { id: 1, title: 'E-book', description: 'descrição mais longa que deve prevalecer', format: 'EBOOK' },\r\n      { id: 2, title: 'Combo SST', description: 'Combo', type: 'PACKAGE' }\r\n    ];\r\n\r\n    apiService.get.and.callFake((path: string) => {\r\n      if (path === '/public/catalog') return of(payload) as any;\r\n      return of([]) as any;\r\n    });\r\n\r\n    service.loadCatalog().subscribe(items => {\r\n      // Deve fazer merge mantendo unicidade por (format::id) e preservar descrição maior\r\n      expect(items.length).toBe(2);\r\n      expect(items.some(item => item.format === 'PACKAGE')).toBeTrue();\r\n      expect(items.some(item => item.format === 'EBOOK' && item.id === '1')).toBeTrue();\r\n      const ebook = items.find(i => i.format === 'EBOOK' && i.id === '1')!;\r\n      expect(ebook.description).toContain('mais longa');\r\n      done();\r\n    });\r\n  });\r\n\r\n  it('retorna fallback (vazio) quando /public/catalog falha', (done) => {\r\n    apiService.get.and.returnValue(throwError(() => new Error('fail')) as any);\r\n\r\n    service.loadCatalog().subscribe((items: CatalogItem[]) => {\r\n      expect(Array.isArray(items)).toBeTrue();\r\n      expect(items.length).toBe(0);\r\n      done();\r\n    });\r\n  });\r\n\r\n  it('carrega setores usando o primeiro endpoint bem-sucedido', (done) => {\r\n    apiService.get.and.callFake((path: string) => {\r\n      if (path === '/api/public/catalog/sectors') {\r\n        return throwError(() => new Error('offline')) as any;\r\n      }\r\n      if (path === '/public/catalog/sectors') {\r\n        return of({ items: [{ id: 'ind', name: 'Indústria' }] }) as any;\r\n      }\r\n      return of([]) as any;\r\n    });\r\n\r\n    service.loadSectors().subscribe(sectors => {\r\n      expect(sectors.length).toBe(1);\r\n      const [sector] = sectors;\r\n      expect(sector.id).toBe('ind');\r\n      expect(sector.name).toBe('Indústria');\r\n      done();\r\n    });\r\n  });\r\n});\r\n", "import { Injectable } from '@angular/core';\r\nimport { catchError, defaultIfEmpty, filter, forkJoin, from, map, of, switchMap, take } from 'rxjs';\r\n\r\nimport { ApiService } from './api.service';\r\n\r\nexport type CatalogFormat = 'EBOOK' | 'RECORDED_COURSE' | 'LIVE_TRAINING' | 'PACKAGE';\r\n\r\nexport interface CatalogItem {\r\n  id: string;\r\n  title: string;\r\n  description: string;\r\n  format: CatalogFormat;\r\n  sectors: string[];\r\n  coverImageUrl?: string | null;\r\n  data?: unknown;\r\n}\r\n\r\nexport interface CatalogSector {\r\n  id: string;\r\n  name: string;\r\n}\r\n\r\n@Injectable({ providedIn: 'root' })\r\nexport class CatalogService {\r\n  constructor(private readonly api: ApiService) {}\r\n\r\n  /**\r\n   * Lista todo o catálogo público usando o endpoint único /public/catalog (resumido).\r\n   * Fallback: se falhar, recorre ao modelo antigo (products + packages + ebooks).\r\n   */\r\n  loadCatalog() {\r\n    const fallback$ = of([] as CatalogItem[]); // métodos legados removidos\r\n\r\n    return this.fetchPublicCatalogAll().pipe(\r\n      map(items => this.mergeDistinct(items)),\r\n      catchError(err => {\r\n        console.warn('[CatalogService] falha em /public/catalog, aplicando fallback composto.', err);\r\n        return fallback$;\r\n      })\r\n    );\r\n  }\r\n\r\n  // Métodos legados de pacotes/planos foram removidos após adoção de /public/catalog.\r\n\r\n  // loadEbooks() removido (catálogo consolidado). Manter fallback se necessário em outro serviço especializado.\r\n\r\n  loadSectors() {\r\n    const endpoints = ['/api/public/catalog/sectors', '/public/catalog/sectors'];\r\n    return from(endpoints).pipe(\r\n      switchMap(endpoint =>\r\n        this.api.get<any>(endpoint).pipe(\r\n          map(response => {\r\n            const list = Array.isArray(response)\r\n              ? response\r\n              : Array.isArray(response?.items)\r\n              ? response.items\r\n              : Array.isArray(response?.data)\r\n              ? response.data\r\n              : [];\r\n            return list.filter(Boolean).map((item: CatalogSector | any) => this.normalizeSector(item));\r\n          }),\r\n          catchError(() => of([] as CatalogSector[]))\r\n        )\r\n      ),\r\n      filter(sectors => sectors.length > 0),\r\n      take(1),\r\n      defaultIfEmpty([] as CatalogSector[])\r\n    );\r\n  }\r\n\r\n  // fetchProducts / fetchPackages removidos (consolidados em catálogo público).\r\n\r\n  /**\r\n   * Tenta buscar planos em endpoints públicos, retornando assim que um deles responder com dados.\r\n   */\r\n  // fetchPlans removido – planos agora fazem parte do catálogo público.\r\n\r\n  // fetchPublicCatalog por tipo removido – endpoint único cobre todos os formatos.\r\n\r\n  /**\r\n   * Busca catálogo completo resumido (todos os formatos) sem filtro de tipo.\r\n   */\r\n  private fetchPublicCatalogAll() {\r\n    return this.api.get<any>('/public/catalog').pipe(\r\n      map(data => {\r\n        const list = Array.isArray(data)\r\n          ? data\r\n          : Array.isArray(data?.items)\r\n          ? data.items\r\n          : Array.isArray(data?.data)\r\n          ? data.data\r\n          : [];\r\n        return list.map((item: any) =>\r\n          this.toCatalogItem(\r\n            item,\r\n            this.normalizeFormat(item?.format ?? item?.type ?? item?.trainingType) ?? 'EBOOK',\r\n            item.coverImageUrl ?? item.imageUrl ?? null\r\n          )\r\n        );\r\n      })\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Faz merge garantindo unicidade por (format::id) e mantém descrição mais longa.\r\n   */\r\n  private mergeDistinct(items: CatalogItem[]): CatalogItem[] {\r\n    const mapById = new Map<string, CatalogItem>();\r\n    for (const item of items) {\r\n      const key = `${item.format}::${item.id}`;\r\n      if (!mapById.has(key)) {\r\n        mapById.set(key, item);\r\n      } else {\r\n        const existing = mapById.get(key)!;\r\n        if ((item.description?.length ?? 0) > (existing.description?.length ?? 0)) {\r\n          mapById.set(key, item);\r\n        }\r\n      }\r\n    }\r\n    return Array.from(mapById.values());\r\n  }\r\n\r\n  private toCatalogItem(raw: any, fallbackFormat: CatalogFormat, cover: string | null): CatalogItem {\r\n    const sectors = Array.isArray(raw?.sectors)\r\n      ? raw.sectors\r\n      : Array.isArray(raw?.assignedSectors)\r\n      ? raw.assignedSectors\r\n      : ['global'];\r\n    return {\r\n  id: String(raw?.id ?? raw?.uuid ?? raw?.code ?? `item-${Math.random().toString(36).slice(2, 9)}`),\r\n      title: raw?.title ?? raw?.name ?? 'Item',\r\n      description: raw?.description ?? raw?.shortDescription ?? '',\r\n      format: this.normalizeFormat(raw?.format ?? raw?.type ?? raw?.trainingType) ?? fallbackFormat,\r\n      sectors: sectors.map((sector: any) =>\r\n        typeof sector === 'string' ? sector : sector?.id ?? sector?.code ?? 'global'\r\n      ),\r\n      coverImageUrl: cover || undefined,\r\n      data: raw\r\n    };\r\n  }\r\n\r\n  private normalizeFormat(value: string | undefined): CatalogFormat | null {\r\n    if (!value) {\r\n      return null;\r\n    }\r\n    const normalized = value.toUpperCase();\r\n    if (normalized.includes('EBOOK')) {\r\n      return 'EBOOK';\r\n    }\r\n    if (normalized.includes('RECORDED') || normalized.includes('GRAV')) {\r\n      return 'RECORDED_COURSE';\r\n    }\r\n    if (normalized.includes('LIVE') || normalized.includes('AO_VIVO')) {\r\n      return 'LIVE_TRAINING';\r\n    }\r\n    if (normalized.includes('PACKAGE')) {\r\n      return 'PACKAGE';\r\n    }\r\n    return null;\r\n  }\r\n\r\n  private normalizeSector(sector: CatalogSector | any): CatalogSector {\r\n    return {\r\n      id: String(sector?.id ?? sector?.uuid ?? sector?.code ?? sector?.slug ?? 'global'),\r\n      name: sector?.name ?? sector?.title ?? sector?.label ?? 'Setor'\r\n    };\r\n  }\r\n\r\n  // Fallbacks específicos removidos. Caso necessário, extrair para um seed estático em outro módulo.\r\n}\r\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AAEA;;;;ACHA;AACA;AAEA;AAoBO,IAAM,iBAAN,MAAMA,gBAAc;EACI;EAA7B,YAA6B,KAAe;AAAf,SAAA,MAAA;EAAkB;;;;;EAM/C,cAAW;AACT,UAAM,YAAY,GAAG,CAAA,CAAmB;AAExC,WAAO,KAAK,sBAAqB,EAAG,KAClC,IAAI,WAAS,KAAK,cAAc,KAAK,CAAC,GACtC,WAAW,SAAM;AACf,cAAQ,KAAK,2EAA2E,GAAG;AAC3F,aAAO;IACT,CAAC,CAAC;EAEN;;;EAMA,cAAW;AACT,UAAM,YAAY,CAAC,+BAA+B,yBAAyB;AAC3E,WAAO,KAAK,SAAS,EAAE,KACrB,UAAU,cACR,KAAK,IAAI,IAAS,QAAQ,EAAE,KAC1B,IAAI,cAAW;AACb,YAAM,OAAO,MAAM,QAAQ,QAAQ,IAC/B,WACA,MAAM,QAAQ,UAAU,KAAK,IAC7B,SAAS,QACT,MAAM,QAAQ,UAAU,IAAI,IAC5B,SAAS,OACT,CAAA;AACJ,aAAO,KAAK,OAAO,OAAO,EAAE,IAAI,CAAC,SAA8B,KAAK,gBAAgB,IAAI,CAAC;IAC3F,CAAC,GACD,WAAW,MAAM,GAAG,CAAA,CAAqB,CAAC,CAAC,CAC5C,GAEH,OAAO,aAAW,QAAQ,SAAS,CAAC,GACpC,KAAK,CAAC,GACN,eAAe,CAAA,CAAqB,CAAC;EAEzC;;;;;;;;;;EAcQ,wBAAqB;AAC3B,WAAO,KAAK,IAAI,IAAS,iBAAiB,EAAE,KAC1C,IAAI,UAAO;AACT,YAAM,OAAO,MAAM,QAAQ,IAAI,IAC3B,OACA,MAAM,QAAQ,MAAM,KAAK,IACzB,KAAK,QACL,MAAM,QAAQ,MAAM,IAAI,IACxB,KAAK,OACL,CAAA;AACJ,aAAO,KAAK,IAAI,CAAC,SACf,KAAK,cACH,MACA,KAAK,gBAAgB,MAAM,UAAU,MAAM,QAAQ,MAAM,YAAY,KAAK,SAC1E,KAAK,iBAAiB,KAAK,YAAY,IAAI,CAC5C;IAEL,CAAC,CAAC;EAEN;;;;EAKQ,cAAc,OAAoB;AACxC,UAAM,UAAU,oBAAI,IAAG;AACvB,eAAW,QAAQ,OAAO;AACxB,YAAM,MAAM,GAAG,KAAK,MAAM,KAAK,KAAK,EAAE;AACtC,UAAI,CAAC,QAAQ,IAAI,GAAG,GAAG;AACrB,gBAAQ,IAAI,KAAK,IAAI;MACvB,OAAO;AACL,cAAM,WAAW,QAAQ,IAAI,GAAG;AAChC,aAAK,KAAK,aAAa,UAAU,MAAM,SAAS,aAAa,UAAU,IAAI;AACzE,kBAAQ,IAAI,KAAK,IAAI;QACvB;MACF;IACF;AACA,WAAO,MAAM,KAAK,QAAQ,OAAM,CAAE;EACpC;EAEQ,cAAc,KAAU,gBAA+B,OAAoB;AACjF,UAAM,UAAU,MAAM,QAAQ,KAAK,OAAO,IACtC,IAAI,UACJ,MAAM,QAAQ,KAAK,eAAe,IAClC,IAAI,kBACJ,CAAC,QAAQ;AACb,WAAO;MACT,IAAI,OAAO,KAAK,MAAM,KAAK,QAAQ,KAAK,QAAQ,QAAQ,KAAK,OAAM,EAAG,SAAS,EAAE,EAAE,MAAM,GAAG,CAAC,CAAC,EAAE;MAC5F,OAAO,KAAK,SAAS,KAAK,QAAQ;MAClC,aAAa,KAAK,eAAe,KAAK,oBAAoB;MAC1D,QAAQ,KAAK,gBAAgB,KAAK,UAAU,KAAK,QAAQ,KAAK,YAAY,KAAK;MAC/E,SAAS,QAAQ,IAAI,CAAC,WACpB,OAAO,WAAW,WAAW,SAAS,QAAQ,MAAM,QAAQ,QAAQ,QAAQ;MAE9E,eAAe,SAAS;MACxB,MAAM;;EAEV;EAEQ,gBAAgB,OAAyB;AAC/C,QAAI,CAAC,OAAO;AACV,aAAO;IACT;AACA,UAAM,aAAa,MAAM,YAAW;AACpC,QAAI,WAAW,SAAS,OAAO,GAAG;AAChC,aAAO;IACT;AACA,QAAI,WAAW,SAAS,UAAU,KAAK,WAAW,SAAS,MAAM,GAAG;AAClE,aAAO;IACT;AACA,QAAI,WAAW,SAAS,MAAM,KAAK,WAAW,SAAS,SAAS,GAAG;AACjE,aAAO;IACT;AACA,QAAI,WAAW,SAAS,SAAS,GAAG;AAClC,aAAO;IACT;AACA,WAAO;EACT;EAEQ,gBAAgB,QAA2B;AACjD,WAAO;MACL,IAAI,OAAO,QAAQ,MAAM,QAAQ,QAAQ,QAAQ,QAAQ,QAAQ,QAAQ,QAAQ;MACjF,MAAM,QAAQ,QAAQ,QAAQ,SAAS,QAAQ,SAAS;;EAE5D;;;;;AA/IW,iBAAc,WAAA;EAD1B,WAAW,EAAE,YAAY,OAAM,CAAE;GACrB,cAAc;;;ADjB3B,SAAS,kBAAkB,MAAK;AAC9B,MAAI;AACJ,MAAI;AAEJ,aAAW,MAAK;AACd,iBAAa,QAAQ,aAAyB,cAAc,CAAC,KAAK,CAAC;AAEnE,YAAQ,uBAAuB;MAC7B,WAAW;QACT;QACA,EAAE,SAAS,YAAY,UAAU,WAAU;;KAE9C;AAED,cAAU,QAAQ,OAAO,cAAc;EACzC,CAAC;AAED,KAAG,yEAAmE,CAAC,SAAQ;AAE7E,UAAM,UAAU;MACd,EAAE,IAAI,GAAG,OAAO,UAAU,aAAa,SAAS,QAAQ,QAAO;MAC/D,EAAE,IAAI,GAAG,OAAO,UAAU,aAAa,kDAA4C,QAAQ,QAAO;MAClG,EAAE,IAAI,GAAG,OAAO,aAAa,aAAa,SAAS,MAAM,UAAS;;AAGpE,eAAW,IAAI,IAAI,SAAS,CAAC,SAAgB;AAC3C,UAAI,SAAS;AAAmB,eAAO,GAAG,OAAO;AACjD,aAAO,GAAG,CAAA,CAAE;IACd,CAAC;AAED,YAAQ,YAAW,EAAG,UAAU,WAAQ;AAEtC,aAAO,MAAM,MAAM,EAAE,KAAK,CAAC;AAC3B,aAAO,MAAM,KAAK,UAAQ,KAAK,WAAW,SAAS,CAAC,EAAE,SAAQ;AAC9D,aAAO,MAAM,KAAK,UAAQ,KAAK,WAAW,WAAW,KAAK,OAAO,GAAG,CAAC,EAAE,SAAQ;AAC/E,YAAM,QAAQ,MAAM,KAAK,OAAK,EAAE,WAAW,WAAW,EAAE,OAAO,GAAG;AAClE,aAAO,MAAM,WAAW,EAAE,UAAU,YAAY;AAChD,WAAI;IACN,CAAC;EACH,CAAC;AAED,KAAG,yDAAyD,CAAC,SAAQ;AACnE,eAAW,IAAI,IAAI,YAAY,WAAW,MAAM,IAAI,MAAM,MAAM,CAAC,CAAQ;AAEzE,YAAQ,YAAW,EAAG,UAAU,CAAC,UAAwB;AACvD,aAAO,MAAM,QAAQ,KAAK,CAAC,EAAE,SAAQ;AACrC,aAAO,MAAM,MAAM,EAAE,KAAK,CAAC;AAC3B,WAAI;IACN,CAAC;EACH,CAAC;AAED,KAAG,2DAA2D,CAAC,SAAQ;AACrE,eAAW,IAAI,IAAI,SAAS,CAAC,SAAgB;AAC3C,UAAI,SAAS,+BAA+B;AAC1C,eAAO,WAAW,MAAM,IAAI,MAAM,SAAS,CAAC;MAC9C;AACA,UAAI,SAAS,2BAA2B;AACtC,eAAO,GAAG,EAAE,OAAO,CAAC,EAAE,IAAI,OAAO,MAAM,eAAW,CAAE,EAAC,CAAE;MACzD;AACA,aAAO,GAAG,CAAA,CAAE;IACd,CAAC;AAED,YAAQ,YAAW,EAAG,UAAU,aAAU;AACxC,aAAO,QAAQ,MAAM,EAAE,KAAK,CAAC;AAC7B,YAAM,CAAC,MAAM,IAAI;AACjB,aAAO,OAAO,EAAE,EAAE,KAAK,KAAK;AAC5B,aAAO,OAAO,IAAI,EAAE,KAAK,cAAW;AACpC,WAAI;IACN,CAAC;EACH,CAAC;AACH,CAAC;",
  "names": ["CatalogService"]
}
